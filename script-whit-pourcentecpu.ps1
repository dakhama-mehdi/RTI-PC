
<#
    .NOTES
    --------------------------------------------------------------------------------
     Generated on:       17/05/2021 21:47
     Generated by:       Dakhama mehdi
    --------------------------------------------------------------------------------
    .DESCRIPTION
        GUI script 
        RTI-PC is a free opensource management tool, 
        which allows you to administer and identify your Windows 10 and server,
        without dependency or installation.
        RTI-PC gives you a control over necessary aspects of your Windows infrastructure to identify and fix problems also inventory you machines.
        It is particularly useful for troubleshooting servers, workstations on private networks that are not connected to the Internet.
#>


#----------------------------------------------
#region Application Functions
#----------------------------------------------

#endregion Application Functions

#----------------------------------------------
# Generated Form Function
#----------------------------------------------
function Show-RTI-PC-radio-test-spourentage-4-with-proc-new_psf {

	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#[void][reflection.assembly]::Load('AspNetMMCExt, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('AspNetMMCExt.resources, Version=2.0.0.0, Culture=fr, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Windows.Forms.DataVisualization, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35')
	[void][reflection.assembly]::Load('System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Define 
	#----------------------------------------------
	try{
		[ProgressBarOverlay] | Out-Null
	}
	catch
	{
		Add-Type -ReferencedAssemblies ('System.Windows.Forms', 'System.Drawing') -TypeDefinition  @" 
		using System;
		using System.Windows.Forms;
		using System.Drawing;
        namespace SAPIENTypes
        {
		    public class ProgressBarOverlay : System.Windows.Forms.ProgressBar
	        {
                public ProgressBarOverlay() : base() { SetStyle(ControlStyles.OptimizedDoubleBuffer | ControlStyles.AllPaintingInWmPaint, true); }
	            protected override void WndProc(ref Message m)
	            { 
	                base.WndProc(ref m);
	                if (m.Msg == 0x000F)// WM_PAINT
	                {
	                    if (Style != System.Windows.Forms.ProgressBarStyle.Marquee || !string.IsNullOrEmpty(this.Text))
                        {
                            using (Graphics g = this.CreateGraphics())
                            {
                                using (StringFormat stringFormat = new StringFormat(StringFormatFlags.NoWrap))
                                {
                                    stringFormat.Alignment = StringAlignment.Center;
                                    stringFormat.LineAlignment = StringAlignment.Center;
                                    if (!string.IsNullOrEmpty(this.Text))
                                        g.DrawString(this.Text, this.Font, Brushes.Black, this.ClientRectangle, stringFormat);
                                    else
                                    {
                                        int percent = (int)(((double)Value / (double)Maximum) * 100);
                                        g.DrawString(percent.ToString() + "%", this.Font, Brushes.Black, this.ClientRectangle, stringFormat);
                                    }
                                }
                            }
                        }
	                }
	            }
              
                public string TextOverlay
                {
                    get
                    {
                        return base.Text;
                    }
                    set
                    {
                        base.Text = value;
                        Invalidate();
                    }
                }
	        }
        }
"@ -IgnoreWarnings | Out-Null
	}
	#endregion Define 

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$RPCInfo = New-Object 'System.Windows.Forms.Form'
	$chartProcesses1 = New-Object 'System.Windows.Forms.DataVisualization.Charting.Chart'
	$datagridview2 = New-Object 'System.Windows.Forms.DataGridView'
	$groupbox1 = New-Object 'System.Windows.Forms.GroupBox'
	$radiobuttonEN = New-Object 'System.Windows.Forms.RadioButton'
	$radiobuttonFr = New-Object 'System.Windows.Forms.RadioButton'
	$button3 = New-Object 'System.Windows.Forms.Button'
	$button2 = New-Object 'System.Windows.Forms.Button'
	$progressbaroverlay1 = New-Object 'SAPIENTypes.ProgressBarOverlay'
	$richtextbox3 = New-Object 'System.Windows.Forms.RichTextBox'
	$richtextbox2 = New-Object 'System.Windows.Forms.RichTextBox'
	$textbox3 = New-Object 'System.Windows.Forms.TextBox'
	$button1 = New-Object 'System.Windows.Forms.Button'
	$datagridview1 = New-Object 'System.Windows.Forms.DataGridView'
	$chartDiskSpace = New-Object 'System.Windows.Forms.DataVisualization.Charting.Chart'
	$richtextbox1 = New-Object 'System.Windows.Forms.RichTextBox'
	$chartProcesses = New-Object 'System.Windows.Forms.DataVisualization.Charting.Chart'
	$textbox2 = New-Object 'System.Windows.Forms.TextBox'
	$textbox1 = New-Object 'System.Windows.Forms.TextBox'
	$buttonOK = New-Object 'System.Windows.Forms.Button'
	$menustrip1 = New-Object 'System.Windows.Forms.MenuStrip'
	$fileToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$aboutToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$exitToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	$RPCInfo_Load={
		#TODO: Initialize Form Controls here
		$textbox1.Text = $env:computername
		$script:communpcname = $textbox1.Text
		
	}
	
	$textbox1_TextChanged={
		#TODO: Place custom script here
		
	}
	
	function testport
	{
		param (
			$hostname
		)
		
		$port = 135
		$timeout = 100
		
		$requestCallback = $state = $null
		$client = New-Object System.Net.Sockets.TcpClient
		$beginConnect = $client.BeginConnect($hostname, $port, $requestCallback, $state)
		Start-Sleep -milli $timeOut
		if ($client.Connected) { $open = $true }
		else { $open = $false }
		$client.Close()
		return ($open)
		[pscustomobject]@{ hostname = $hostname; port = $port; open = $open }
	}
	
	$buttonOK_Click = {
		#TODO: Place custom script here
		$datagridview1.DataSource = $null
		$textbox2.Clear()
		$progressbaroverlay1.Maximum = 100
		$progressbaroverlay1.Step = 1
		$progressbaroverlay1.Visible = $true
		$progressbaroverlay1.Value = 0
		$computername = $textbox1.Text
		$progressbaroverlay1.Increment(10)
		
		if ($radiobuttonFr.Checked -eq $True)
		{
			
			$String = @("Tester la connexion au poste", "machine enligne", "Tester la connexion au service Winrm")
			
		}
		else
		{
			
			$string = $null
			$String = @("Try connection to computer", "computer is online", "Check Winrm service")
			
		}
		
		$textbox2.Text += "`r`n" + "`r`n" + "`r`n" + $string[0] + "`r`n"
		$textbox2.Text += "`r`n" + "`r`n" + "`r`n" + $string[1] + "`r`n"
		$progressbaroverlay1.Increment(20)
		
		
		$checkport = testport $computername
		if ($checkport -eq $true)
		{
			$progressbaroverlay1.Increment(10)
			$textbox2.Text += "`r`n" + $string[2] + "`r`n"
			$progressbaroverlay1.Increment(10)
			
			
			if ($script:communpcname -ne $computername)
			{
				try
				{
					
					Test-WSMan -ComputerName $computername -Authentication Default -ErrorAction Stop -ErrorVariable probleme
					
				}
				catch
				{
					$textbox2.Text += "`r`n" + $probleme.message
					$computername = $null
					$progressbaroverlay1.Increment(100)
				}
			}
			
			if ($computername)
			{
				if ($script:communpcname -eq $computername)
				{
					$par = @{
					}
				}
				else
				{
					
					$par = @{
						computername   = $computername
					}
				}
				
				#recupere les processus consommant le plus de charge
				$Processes1 = Invoke-Command @par -ScriptBlock { Get-Process | Sort-Object -Property cpu | Select-Object Name, WS, ID, cpu -Last 5 }
				$ProcNames1 = Invoke-Command @par -ScriptBlock {
					
					@(foreach ($Proc in (Get-Process | Sort-Object -Property cpu | Select-Object Name, WS, ID, cpu -Last 5))
						{
							$sleepseconds = 1
							$numcores = 1
							$cpu1 = (get-process -id $Proc.id).cpu
							sleep $sleepseconds
							$cpu2 = (get-process -id $proc.id).cpu
							$cpupercent = [int](($cpu2 - $cpu1)/($numcores * $sleepseconds) * 100)
							$Proc.Name + "  (" + $cpupercent + "%)"
							
						})
				}
				
						
				$WS1 = @(foreach ($Proc in $Processes1) { $Proc.WS/1MB })
				Update-Chart1 $chartProcesses1 -XPoints $ProcNames1[0] -YPoints $WS1[0]
				$chartProcesses1.Series[0].Points.AddXY($ProcNames1[1], $ws1[1])
				$chartProcesses1.Series[0].Points.AddXY($ProcNames1[2], $ws1[2])
				$chartProcesses1.Series[0].Points.AddXY($ProcNames1[3], $ws1[3])
				$chartProcesses1.Series[0].Points.AddXY($ProcNames1[4], $ws1[4])
				
				#tableau des process les plus utilisés
				$Processes = Invoke-Command @par -ScriptBlock { Get-Process | Sort-Object -Property WS | Select-Object Name, WS -Last 7 }
				$ProcNames = @(foreach ($Proc in $Processes) { $Proc.Name })
				$WS = @(foreach ($Proc in $Processes) { $Proc.WS/1MB })
				Update-Chart $chartProcesses -XPoints $ProcNames -YPoints $WS
				
				#recuperer la mémoire disponible
				$q = Invoke-Command @par -ScriptBlock { Get-WmiObject Win32_OperatingSystem | select freePhysical* }
				
				#recupere l'espace disque dure
				$Disks = Invoke-Command @par -ScriptBlock { (Get-WMIObject Win32_LogicalDisk -filter "DriveType=3") }
				$progressbaroverlay1.Increment(10)
				Clear-Chart $chartDiskSpace
				foreach ($disk in $Disks)
				{
					$UsedSpace = (($disk.size - $disk.freespace)/1gb)
					$FreeSpace = ($disk.freespace/1gb)
					
					Update-Chart $chartDiskSpace -XPoints ("Occupé ({0:N1} GB)" -f $UsedSpace), (" ({0:N1} GB)" -f $FreeSpace) -YPoints $UsedSpace, $FreeSpace -ChartType "Pie" -Title ("Volume: {0} ({1:N1} GB)" -f $disk.Deviceid, ($disk.size/1gb)) -Append
				}
				foreach ($Series in $chartDiskSpace.Series)
				{
					$Series.CustomProperties = "PieDrawingStyle=Concave"
				}
				
				
				$progressbaroverlay1.Increment(10)
				
				#recuperer les élements manquants  
				$p = (Get-NetConnectionProfile).NetworkCategory
				Get-NetFirewallProfile -Name $p | fl Enabled
				
				
				
				$f = Invoke-Command @par -ScriptBlock {
					
					#$FW = Get-NetFirewallProfile | Select Name, Enabled
					$fw1 = (Get-NetConnectionProfile).NetworkCategory
					if ($fw1 -like "domain*")
					{
						$fw1 = "domain"
					}
					$state = (Get-NetFirewallProfile -Name $fw1).Enabled
					
					$bios = Get-WmiObject win32_bios
					
					
					$logonserver = nltest /sc_query:$env:USERDNSDOMAIN
					
					Get-CimInstance -ClassName Win32_ComputerSystem | select @{ n = 'Utilisateur'; e = { $_.UserName } }, @{ n = 'Objet'; e = { $_.Manufacturer } }, @{ n = 'Class'; e = { $_.model } },
																			 @{ n = 'NatureAudit'; e = { ((Get-NetIpConfiguration).Ipv4Address).ipaddress } },
																			 @{ n = 'RAM'; e = { ("{0:N2}" -f (((Get-WmiObject Win32_OperatingSystem | select TotalVisibleMemorySize).TotalVisibleMemorySize)/1mb)) } },
																			 @{ n = 'Serial_number'; e = { ($Bios).serialnumber } },
																			 @{ n = 'Adresse_MAC'; e = { (Get-NetIPConfiguration | Get-NetAdapter).MacAddress } },
																			 @{ n = 'OS'; e = { (Get-ItemProperty -Path registry::"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion").productname } },
																			 @{ n = 'FWPROFIL'; e = { $fw1 } },
																			 @{ n = 'FWState'; e = { $state } },
																			 @{ n = 'Bios_Info'; e = { $Bios.name } },
																			 @{ n = 'Logon_Domain'; e = { $logonserver[1].Split("\\")[2] } }
					
					
				}
				
				
				$progressbaroverlay1.Increment(20)
				$richtextbox3.Text = "Ram Libre " + ("{0:N2}" -f (($q.FreePhysicalMemory)/1mb)) + " GB"
				$progressbaroverlay1.Visible = $false
				$textbox2.Clear()
				
				if ($radiobuttonFr.Checked -eq $true)
				{
					$label = @('Utilisateur en cours :', 'Marque :', 'Model :', 'Adresse IP :', 'Quantité de Ram en GB :', 'Numero de Serie :', 'Adresse MAC:', 'Système :', 'Profil du Parefeu :', 'Profil  Actif :', 'Version Bios :', 'Logon Server :')
				}
				else
				{
					$label = @('Current user :', 'Mmanufacturer :', 'Model :', 'IP Address :', 'RAM Total on GB :', 'Serial Number :', 'MAC Address:', 'System :', 'Firewall Profil Type :', 'Profil  Actif :', 'Bios Info :', 'Logon Server :')
				}
				$object = @($f.Utilisateur, $f.Objet, $f.Class, $f.NatureAudit, $f.RAM, $f.Serial_number, $f.Adresse_MAC, $f.OS, $f.FWPROFIL, $f.FWState, $f.Bios_Info, $f.Logon_Domain)
				
				$textbox2.Text += "`r`n" + "`r`n"
				
				foreach ($i in 0 .. 11)
				{
					
					$textbox2.Text += Write-Output $label[$i]  $object[$i]
					$textbox2.Text += "`r`n" + "`r`n"
					
				}
				
				
				checkreability @par
			}
			
		}
		else
		{
			$textbox2.Text += "pas de ping " + "`r`n"
			$textbox2.Text += "Poste injoingalbe ,verifier connexion ,ou eteint  " + "`r`n"
			$progressbaroverlay1.Increment(50)
			$progressbaroverlay1.Increment(100)
		}
	}
	
	function checkreability ($computername)
	{
		
		$20DaysAgo = (Get-Date).AddDays(-20).ToString("dd/MM/yyyy")
		$datagridview2.Rows.Clear()
		$datagridview2.Columns.Clear()
		$datagridview2.Columns.Add('0', 'Type')
		$datagridview2.Columns.Add('1', 'Time')
		$datagridview2.Columns.Add('2', 'Product')
		$datagridview2.Columns.Add('3', 'Message')
		$datagridview2.Columns['0'].Width = 100
		$datagridview2.Columns['1'].Width = 100
		$datagridview2.Columns['2'].Width = 150
		
		$i = 0
		Get-CimInstance -ClassName Win32_ReliabilityRecords -filter "TimeGenerated > '$20DaysAgo'" -ComputerName $computername | Sort-Object TimeGenerated | Select-Object @{ n = 'Type'; e = { (Get-WinEvent -FilterHashTable @{ LogName = $_.Logfile; ID = $_.EventIdentifier } -MaxEvents 1).LevelDisplayName } }, timegenerated, message, productname | ForEach-Object {
			
			
			
			$datagridview2.Rows.Add($_.type, $_.timegenerated, $_.ProductName, $_.Message)
			
			if ($_.type -like '*Err*')
			{
				
				$datagridview2.rows[$i].Cells[0].Style.BackColor = 'Red'
				
			}
			elseif ($_.type -like '*averti*' -or $_.type -like '*warr*')
			{
				
				$datagridview2.rows[$i].Cells[0].Style.BackColor = 'Yellow'
				
			}
			
			
			$i++
			
			$datagridview2.FirstDisplayedScrollingRowIndex = $datagridview2.RowCount - 1
			$datagridview2.Rows[$datagridview2.RowCount - 1].Selected = $true
			
			
		}
	}
	
	$textbox2_TextChanged={
		#TODO: Place custom script here
		
	}
	
	$textbox1_KeyDown=[System.Windows.Forms.KeyEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.KeyEventArgs]
		#TODO: Place custom script here
		if ($_.KeyCode -eq "Enter") { & $buttonOK_Click }
	}
	
	$chartProcesses_VisibleChanged={
		if($this.Visible)
		{
			Update-ProcessChart -Chart $this -Top 7	
		}
	}
	
	#region Control Helper Functions
	function Update-ComboBox
	{
	<#
		.SYNOPSIS
			This functions helps you load items into a ComboBox.
		
		.DESCRIPTION
			Use this function to dynamically load items into the ComboBox control.
		
		.PARAMETER ComboBox
			The ComboBox control you want to add items to.
		
		.PARAMETER Items
			The object or objects you wish to load into the ComboBox's Items collection.
		
		.PARAMETER DisplayMember
			Indicates the property to display for the items in this control.
		
		.PARAMETER Append
			Adds the item(s) to the ComboBox without clearing the Items collection.
		
		.EXAMPLE
			Update-ComboBox $combobox1 "Red", "White", "Blue"
		
		.EXAMPLE
			Update-ComboBox $combobox1 "Red" -Append
			Update-ComboBox $combobox1 "White" -Append
			Update-ComboBox $combobox1 "Blue" -Append
		
		.EXAMPLE
			Update-ComboBox $combobox1 (Get-Process) "ProcessName"
		
		.NOTES
			Additional information about the function.
	#>
		
		param
		(
			[Parameter(Mandatory = $true)]
			[ValidateNotNull()]
			[System.Windows.Forms.ComboBox]
			$ComboBox,
			[Parameter(Mandatory = $true)]
			[ValidateNotNull()]
			$Items,
			[Parameter(Mandatory = $false)]
			[string]
			$DisplayMember,
			[switch]
			$Append
		)
		
		if (-not $Append)
		{
			$ComboBox.Items.Clear()
		}
		
		if ($Items -is [Object[]])
		{
			$ComboBox.Items.AddRange($Items)
		}
		elseif ($Items -is [System.Collections.IEnumerable])
		{
			$ComboBox.BeginUpdate()
			foreach ($obj in $Items)
			{
				$ComboBox.Items.Add($obj)
			}
			$ComboBox.EndUpdate()
		}
		else
		{
			$ComboBox.Items.Add($Items)
		}
		
		$ComboBox.DisplayMember = $DisplayMember
	}
	
	function Update-DataGridView
	{
		<#
		.SYNOPSIS
			This functions helps you load items into a DataGridView.
	
		.DESCRIPTION
			Use this function to dynamically load items into the DataGridView control.
	
		.PARAMETER  DataGridView
			The DataGridView control you want to add items to.
	
		.PARAMETER  Item
			The object or objects you wish to load into the DataGridView's items collection.
		
		.PARAMETER  DataMember
			Sets the name of the list or table in the data source for which the DataGridView is displaying data.
	
		.PARAMETER AutoSizeColumns
		    Resizes DataGridView control's columns after loading the items.
		#>
		Param (
			[ValidateNotNull()]
			[Parameter(Mandatory=$true)]
			[System.Windows.Forms.DataGridView]$DataGridView,
			[ValidateNotNull()]
			[Parameter(Mandatory=$true)]
			$Item,
		    [Parameter(Mandatory=$false)]
			[string]$DataMember,
			[System.Windows.Forms.DataGridViewAutoSizeColumnMode]$AutoSizeColumns = 'None'
		)
		$DataGridView.SuspendLayout()
		$DataGridView.DataMember = $DataMember
		
		if ($Item -is [System.Data.DataSet] -and $Item.Tables.Count -gt 0)
		{
			$DataGridView.DataSource = $Item.Tables[0]
		}
		elseif ($Item -is [System.ComponentModel.IListSource]`
		-or $Item -is [System.ComponentModel.IBindingList] -or $Item -is [System.ComponentModel.IBindingListView] )
		{
			$DataGridView.DataSource = $Item
		}
		else
		{
			$array = New-Object System.Collections.ArrayList
			
			if ($Item -is [System.Collections.IList])
			{
				$array.AddRange($Item)
			}
			else
			{
				$array.Add($Item)
			}
			$DataGridView.DataSource = $array
		}
		
		if ($AutoSizeColumns -ne 'None')
		{
			$DataGridView.AutoResizeColumns($AutoSizeColumns)
		}
		
		$DataGridView.ResumeLayout()
	}
	
	function ConvertTo-DataTable
	{
		<#
			.SYNOPSIS
				Converts objects into a DataTable.
		
			.DESCRIPTION
				Converts objects into a DataTable, which are used for DataBinding.
		
			.PARAMETER  InputObject
				The input to convert into a DataTable.
		
			.PARAMETER  Table
				The DataTable you wish to load the input into.
		
			.PARAMETER RetainColumns
				This switch tells the function to keep the DataTable's existing columns.
			
			.PARAMETER FilterWMIProperties
				This switch removes WMI properties that start with an underline.
		
			.EXAMPLE
				$DataTable = ConvertTo-DataTable -InputObject (Get-Process)
		#>
		[OutputType([System.Data.DataTable])]
		param(
		[ValidateNotNull()]
		$InputObject, 
		[ValidateNotNull()]
		[System.Data.DataTable]$Table,
		[switch]$RetainColumns,
		[switch]$FilterWMIProperties)
		
		if($null -eq $Table)
		{
			$Table = New-Object System.Data.DataTable
		}
		
		if ($InputObject -is [System.Data.DataTable])
		{
			$Table = $InputObject
		}
		elseif ($InputObject -is [System.Data.DataSet] -and $InputObject.Tables.Count -gt 0)
		{
			$Table = $InputObject.Tables[0]
		}
		else
		{
			if (-not $RetainColumns -or $Table.Columns.Count -eq 0)
			{
				#Clear out the Table Contents
				$Table.Clear()
				
				if ($null -eq $InputObject) { return } #Empty Data
				
				$object = $null
				#find the first non null value
				foreach ($item in $InputObject)
				{
					if ($null -ne $item)
					{
						$object = $item
						break
					}
				}
				
				if ($null -eq $object) { return } #All null then empty
				
				#Get all the properties in order to create the columns
				foreach ($prop in $object.PSObject.Get_Properties())
				{
					if (-not $FilterWMIProperties -or -not $prop.Name.StartsWith('__')) #filter out WMI properties
					{
						#Get the type from the Definition string
						$type = $null
						
						if ($null -ne $prop.Value)
						{
							try { $type = $prop.Value.GetType() }
							catch { Out-Null }
						}
						
						if ($null -ne $type) # -and [System.Type]::GetTypeCode($type) -ne 'Object')
						{
							[void]$table.Columns.Add($prop.Name, $type)
						}
						else #Type info not found
						{
							[void]$table.Columns.Add($prop.Name)
						}
					}
				}
				
				if ($object -is [System.Data.DataRow])
				{
					foreach ($item in $InputObject)
					{
						$Table.Rows.Add($item)
					}
					return @( ,$Table)
				}
			}
			else
			{
				$Table.Rows.Clear()
			}
			
			foreach ($item in $InputObject)
			{
				$row = $table.NewRow()
				
				if ($item)
				{
					foreach ($prop in $item.PSObject.Get_Properties())
					{
						if ($table.Columns.Contains($prop.Name))
						{
							$row.Item($prop.Name) = $prop.Value
						}
					}
				}
				[void]$table.Rows.Add($row)
			}
		}
		
		return @(,$Table)	
	}
	
	function Update-ListViewColumnSort
	{
	<#
		.SYNOPSIS
			Sort the ListView's item using the specified column.
		
		.DESCRIPTION
			Sort the ListView's item using the specified column.
			This function uses Add-Type to define a class that sort the items.
			The ListView's Tag property is used to keep track of the sorting.
		
		.PARAMETER ListView
			The ListView control to sort.
		
		.PARAMETER ColumnIndex
			The index of the column to use for sorting.
		
		.PARAMETER SortOrder
			The direction to sort the items. If not specified or set to None, it will toggle.
		
		.EXAMPLE
			Update-ListViewColumnSort -ListView $listview1 -ColumnIndex 0
		
		.NOTES
			Additional information about the function.
	#>
		
		param
		(
			[Parameter(Mandatory = $true)]
			[ValidateNotNull()]
			[System.Windows.Forms.ListView]
			$ListView,
			[Parameter(Mandatory = $true)]
			[int]
			$ColumnIndex,
			[System.Windows.Forms.SortOrder]
			$SortOrder = 'None'
		)
		
		if (($ListView.Items.Count -eq 0) -or ($ColumnIndex -lt 0) -or ($ColumnIndex -ge $ListView.Columns.Count))
		{
			return;
		}
		
		#region Define ListViewItemComparer
		try
		{
			[ListViewItemComparer] | Out-Null
		}
		catch
		{
			Add-Type -ReferencedAssemblies ('System.Windows.Forms') -TypeDefinition  @" 
	using System;
	using System.Windows.Forms;
	using System.Collections;
	public class ListViewItemComparer : IComparer
	{
	    public int column;
	    public SortOrder sortOrder;
	    public ListViewItemComparer()
	    {
	        column = 0;
			sortOrder = SortOrder.Ascending;
	    }
	    public ListViewItemComparer(int column, SortOrder sort)
	    {
	        this.column = column;
			sortOrder = sort;
	    }
	    public int Compare(object x, object y)
	    {
			if(column >= ((ListViewItem)x).SubItems.Count)
				return  sortOrder == SortOrder.Ascending ? -1 : 1;
		
			if(column >= ((ListViewItem)y).SubItems.Count)
				return sortOrder == SortOrder.Ascending ? 1 : -1;
		
			if(sortOrder == SortOrder.Ascending)
	        	return String.Compare(((ListViewItem)x).SubItems[column].Text, ((ListViewItem)y).SubItems[column].Text);
			else
				return String.Compare(((ListViewItem)y).SubItems[column].Text, ((ListViewItem)x).SubItems[column].Text);
	    }
	}
"@ | Out-Null
		}
		#endregion
		
		if ($ListView.Tag -is [ListViewItemComparer])
		{
			#Toggle the Sort Order
			if ($SortOrder -eq [System.Windows.Forms.SortOrder]::None)
			{
				if ($ListView.Tag.column -eq $ColumnIndex -and $ListView.Tag.sortOrder -eq 'Ascending')
				{
					$ListView.Tag.sortOrder = 'Descending'
				}
				else
				{
					$ListView.Tag.sortOrder = 'Ascending'
				}
			}
			else
			{
				$ListView.Tag.sortOrder = $SortOrder
			}
			
			$ListView.Tag.column = $ColumnIndex
			$ListView.Sort() #Sort the items
		}
		else
		{
			if ($SortOrder -eq [System.Windows.Forms.SortOrder]::None)
			{
				$SortOrder = [System.Windows.Forms.SortOrder]::Ascending
			}
			
			#Set to Tag because for some reason in PowerShell ListViewItemSorter prop returns null
			$ListView.Tag = New-Object ListViewItemComparer ($ColumnIndex, $SortOrder)
			$ListView.ListViewItemSorter = $ListView.Tag #Automatically sorts
		}
	}
	
	
	function Add-ListViewItem
	{
	<#
		.SYNOPSIS
			Adds the item(s) to the ListView and stores the object in the ListViewItem's Tag property.
	
		.DESCRIPTION
			Adds the item(s) to the ListView and stores the object in the ListViewItem's Tag property.
	
		.PARAMETER ListView
			The ListView control to add the items to.
	
		.PARAMETER Items
			The object or objects you wish to load into the ListView's Items collection.
			
		.PARAMETER  ImageIndex
			The index of a predefined image in the ListView's ImageList.
		
		.PARAMETER  SubItems
			List of strings to add as Subitems.
		
		.PARAMETER Group
			The group to place the item(s) in.
		
		.PARAMETER Clear
			This switch clears the ListView's Items before adding the new item(s).
		
		.EXAMPLE
			Add-ListViewItem -ListView $listview1 -Items "Test" -Group $listview1.Groups[0] -ImageIndex 0 -SubItems "Installed"
	#>
		
		Param( 
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		[System.Windows.Forms.ListView]$ListView,
		[ValidateNotNull()]
		[Parameter(Mandatory=$true)]
		$Items,
		[int]$ImageIndex = -1,
		[string[]]$SubItems,
		$Group,
		[switch]$Clear)
		
		if($Clear)
		{
			$ListView.Items.Clear();
	    }
	    
	    $lvGroup = $null
	    if ($Group -is [System.Windows.Forms.ListViewGroup])
	    {
	        $lvGroup = $Group
	    }
	    elseif ($Group -is [string])
	    {
	        #$lvGroup = $ListView.Group[$Group] # Case sensitive
	        foreach ($groupItem in $ListView.Groups)
	        {
	            if ($groupItem.Name -eq $Group)
	            {
	                $lvGroup = $groupItem
	                break
	            }
	        }
	        
	        if ($null -eq $lvGroup)
	        {
	            $lvGroup = $ListView.Groups.Add($Group, $Group)
	        }
	    }
	    
		if($Items -is [Array])
		{
			$ListView.BeginUpdate()
			foreach ($item in $Items)
			{		
				$listitem  = $ListView.Items.Add($item.ToString(), $ImageIndex)
				#Store the object in the Tag
				$listitem.Tag = $item
				
				if($null -ne $SubItems)
				{
					$listitem.SubItems.AddRange($SubItems)
				}
				
				if($null -ne $lvGroup)
				{
					$listitem.Group = $lvGroup
				}
			}
			$ListView.EndUpdate()
		}
		else
		{
			#Add a new item to the ListView
			$listitem  = $ListView.Items.Add($Items.ToString(), $ImageIndex)
			#Store the object in the Tag
			$listitem.Tag = $Items
			
			if($null -ne $SubItems)
			{
				$listitem.SubItems.AddRange($SubItems)
			}
			
			if($null -ne $lvGroup)
			{
				$listitem.Group = $lvGroup
			}
		}
	}
	
	
	
	
	
	
	function Update-Chart
	{
	
		param
		(
			[Parameter(Mandatory = $true,
					   Position = 1)]
			[ValidateNotNull()]
			[System.Windows.Forms.DataVisualization.Charting.Chart]
			$ChartControl,
			[Parameter(Mandatory = $true,
					   Position = 2)]
			[ValidateNotNull()]
			$XPoints,
			[Parameter(Mandatory = $true,
					   Position = 3)]
			$YPoints,
			[Parameter(Mandatory = $false,
					   Position = 4)]
			[string]
			$XTitle,
			[Parameter(Mandatory = $false,
					   Position = 5)]
			[string]
			$YTitle,
			[Parameter(Mandatory = $false,
					   Position = 6)]
			[string]
			$Title,
			[Parameter(Mandatory = $false,
					   Position = 7)]
			[System.Windows.Forms.DataVisualization.Charting.SeriesChartType]
			$ChartType,
			[Parameter(Mandatory = $false,
					   Position = 8)]
			$SeriesIndex = '-1',
			[Parameter(Mandatory = $false,
					   Position = 9)]
			$TitleIndex = '0',
			[Parameter(Mandatory = $false)]
			[string]
			$SeriesName = $null,
			[switch]
			$Enable3D,
			[switch]
			$Disable3D,
			[switch]
			$AppendNew
		)
		
		$ChartAreaIndex = 0
		if ($AppendNew)
		{
			$name = "ChartArea " + ($ChartControl.ChartAreas.Count + 1).ToString();
			$ChartArea = $ChartControl.ChartAreas.Add($name)
			$ChartAreaIndex = $ChartControl.ChartAreas.Count - 1
			
			$name = "Series " + ($ChartControl.Series.Count + 1).ToString();
			$Series = $ChartControl.Series.Add($name)
			$SeriesIndex = $ChartControl.Series.Count - 1
			
			$Series.ChartArea = $ChartArea.Name
			
			if ($Title)
			{
				$name = "Title " + ($ChartControl.Titles.Count + 1).ToString();
				$TitleObj = $ChartControl.Titles.Add($Title)
				$TitleIndex = $ChartControl.Titles.Count - 1
				$TitleObj.DockedToChartArea = $ChartArea.Name
				$TitleObj.IsDockedInsideChartArea = $false
			}
		}
		else
		{
			if ($ChartControl.ChartAreas.Count -eq 0)
			{
				$name = "ChartArea " + ($ChartControl.ChartAreas.Count + 1).ToString();
				[void]$ChartControl.ChartAreas.Add($name)
				$ChartAreaIndex = $ChartControl.ChartAreas.Count - 1
			}
			
			if ($ChartControl.Series.Count -eq 0)
			{
				if (-not $SeriesName)
				{
					$SeriesName = "Series " + ($ChartControl.Series.Count + 1).ToString();
				}
				
				$Series = $ChartControl.Series.Add($SeriesName)
				$SeriesIndex = $ChartControl.Series.Count - 1
				$Series.ChartArea = $ChartControl.ChartAreas[$ChartAreaIndex].Name
			}
			elseif ($SeriesName)
			{
				$Series = $ChartControl.Series.FindByName($SeriesName)
				
				if ($null -eq $Series)
				{
					if (($SeriesIndex -gt -1) -and ($SeriesIndex -lt $ChartControl.Series.Count))
					{
						$Series = $ChartControl.Series[$SeriesIndex]
						$Series.Name = $SeriesName
					}
					else
					{
						$Series = $ChartControl.Series.Add($SeriesName)
						$SeriesIndex = $ChartControl.Series.Count - 1
					}
					
					$Series.ChartArea = $ChartControl.ChartAreas[$ChartAreaIndex].Name
				}
				else
				{
					$SeriesIndex = $ChartControl.Series.IndexOf($Series)
					$ChartAreaIndex = $ChartControl.ChartAreas.IndexOf($Series.ChartArea)
				}
			}
		}
		
		if (($SeriesIndex -lt 0) -or ($SeriesIndex -ge $ChartControl.Series.Count))
		{
			$SeriesIndex = 0
		}
		
		$Series = $ChartControl.Series[$SeriesIndex]
		$Series.Points.Clear()
		$ChartArea = $ChartControl.ChartAreas[$Series.ChartArea]
		$ChartArea.BackColor = 'Transparent'
		#$ChartArea.AxisX.TitleForeColor = 'White'
		#$ChartArea.AxisX2.TitleForeColor = 'White'
		#$ChartArea.AxisY.TitleForeColor = 'White'
		$ChartArea.AxisY2.TitleForeColor = 'White'
		
		if ($Enable3D)
		{
			$ChartArea.Area3DStyle.Enable3D = $true
		}
		elseif ($Disable3D)
		{
			$ChartArea.Area3DStyle.Enable3D = $false
		}
		
		if ($Title)
		{
			if ($ChartControl.Titles.Count -eq 0)
			{
				$name = "Title " + ($ChartControl.Titles.Count + 1).ToString();
				$TitleObj = $ChartControl.Titles.Add($Title)
				$TitleIndex = $ChartControl.Titles.Count - 1
				$TitleObj.DockedToChartArea = $ChartArea.Name
				$TitleObj.IsDockedInsideChartArea = $false
			}
			
			#$ChartControl.Titles[$TitleIndex].Text = $Title
		}
		
		if ($ChartType)
		{
			$Series.ChartType = $ChartType
		}
		
		if ($XTitle)
		{
			$ChartArea.AxisX.Title = $XTitle
			}
		
		if ($YTitle)
		{
			$ChartArea.AxisY.Title = $YTitle
			}
		
		if ($XPoints -isnot [Array] -or $XPoints -isnot [System.Collections.IEnumerable])
		{
			$array = New-Object System.Collections.ArrayList
			$array.Add($XPoints)
			$XPoints = $array
		}
		
		if ($YPoints -isnot [Array] -or $YPoints -isnot [System.Collections.IEnumerable])
		{
			$array = New-Object System.Collections.ArrayList
			$array.Add($YPoints)
			$YPoints = $array
		}
		
		$Series.Points.DataBindXY($XPoints, $YPoints)
	}
	
	
	function Clear-Chart
	{
		Param (	
		[ValidateNotNull()]
		[Parameter(Position=1,Mandatory=$true)]
	  	[System.Windows.Forms.DataVisualization.Charting.Chart]$ChartControl
		,
		[Parameter(Position=2, Mandatory=$false)]
		[Switch]$LeaveSingleChart
		)
		
		$count = 0	
		if($LeaveSingleChart)
		{
			$count = 1
		}
		
		while($ChartControl.Series.Count -gt $count)
		{
			$ChartControl.Series.RemoveAt($ChartControl.Series.Count - 1)
		}
		
		while($ChartControl.ChartAreas.Count -gt $count)
		{
			$ChartControl.ChartAreas.RemoveAt($ChartControl.ChartAreas.Count - 1)
		}
		
		while($ChartControl.Titles.Count -gt $count)
		{
			$ChartControl.Titles.RemoveAt($ChartControl.Titles.Count - 1)
		}
		
		if($ChartControl.Series.Count -gt 0)
		{
			$ChartControl.Series[0].Points.Clear()
		}
	}
	#endregion
	
	function Update-ProcessChart
	{
		Param ( [Parameter(Position=1,Mandatory=$true)]
				[System.Windows.Forms.DataVisualization.Charting.Chart]$Chart,
				[int]$Top = 7)
		
		$Processes = Get-Process | Sort-Object -Property WS | Select-Object Name,WS,ID -Last $Top 
		$ProcNames = @(foreach($Proc in $Processes){$Proc.Name }) 
		$WS = @(foreach($Proc in $Processes){$Proc.WS/1MB}) 
	
		Update-Chart $Chart -XPoints $ProcNames -YPoints $WS -Title "Top $Top Processes"
	}
	
	$chartProcesses_Click={
		#TODO: Place custom script here
		$val = $textbox1.Text
		$session = New-PSSession -ComputerName $val
		$q = Invoke-Command -computername $val -ScriptBlock { Get-WmiObject Win32_OperatingSystem | select freePhysical* }
		$Processes = Invoke-Command -computername $val -ScriptBlock {Get-Process | Sort-Object -Property cpu | Select-Object Name, WS -Last 7 }
		$ProcNames = @(foreach ($Proc in $Processes) { $Proc.Name })
		$WS = @(foreach ($Proc in $Processes) { $Proc.WS/1MB })
		Update-Chart $chartProcesses -XPoints $ProcNames -YPoints $WS -Title "Top 5 Processes"
		$richtextbox3.Text = "Ram Libre " + ("{0:N2}" -f (($q.FreePhysicalMemory)/1mb)) + " GB"
	}
	
	
	$progressbar1_Click={
		#TODO: Place custom script here
		
	}
	
	$chartDiskSpace_VisibleChanged={
		if($this.Visible)
		{
			Update-DiskChart $this
		}
	}
	
	#Call Update-DiskChart function to load the chart
	function Update-DiskChart
	{
		Param ( [Parameter(Position=1,Mandatory=$true)]
				[System.Windows.Forms.DataVisualization.Charting.Chart]$Chart)
		#Get Disk space using WMI and make sure it is an array
		$Disks = @(Get-WMIObject Win32_LogicalDisk -filter "DriveType=3" |Where-Object {$_.deviceid -like "C:" } )
			
		#Remove all the current charts
		Clear-Chart $Chart 
		
		#Loop through each drive
		foreach($disk in $Disks)
		{	
			$UsedSpace =(($disk.size - $disk.freespace)/1gb)
			$FreeSpace = ($disk.freespace/1gb)
	
			#Load a Chart for each Drive
			Update-Chart $Chart -XPoints ("Occupé ({0:N1} GB)" -f $UsedSpace), (" ({0:N1} GB)" -f $FreeSpace) -YPoints $UsedSpace, $FreeSpace -ChartType "Pie" -Title ("Volume: {0} ({1:N1} GB)" -f $disk.Deviceid, ($disk.size/1gb) ) -Append	
		}
		
		#Set Custom Style
		foreach ($Series in $chartDiskSpace.Series)
		{
			$Series.CustomProperties = "PieDrawingStyle=Concave"
		}
	}
	
	$listviewSort_ColumnClick=[System.Windows.Forms.ColumnClickEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.ColumnClickEventArgs]
		Update-ListViewColumnSort -ListView $this -ColumnIndex $_.Column
	}
	
	$buttonCancelProcess_Click={
		$script:CancelLoop = $true
	}
	
	$buttonStartProcess_Click={
		#Init CancelLoop
		$script:CancelLoop = $false
		$buttonCancelProcess.Enabled = $true
		#Disable the button so we don't trigger it again
		$this.Enabled = $false
		#Reset the Progress Bar
		$progressbar2.Value = 0
		
		for($i = 0; $i -lt $progressbar2.Maximum; $i++)
		{
			#----------------------------------------
			#Place custom script here
			sleep -Milliseconds 200
			
			#----------------------------------------
			#process the pending message
			[System.Windows.Forms.Application]::DoEvents()
			
			if($script:CancelLoop -eq $true)
			{
				#Clear the progress bar
				$progressbar2.Value = 0
				#Exit the loop
				break;
			}
			#Step the progress bar
			$progressbar2.PerformStep() 
		}
		
		#Enable the button so we can click it again
		$this.Enabled = $true
		$buttonCancelProcess.Enabled = $false
	}
	
	
	$datagridview1_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
		#TODO: Place custom script here
	}
	
	$button1_Click={
		#TODO: Place custom script here
		$datagridview1.DataSource = $null
		$machine = $textbox1.Text
		$logiciel = '*' + $textbox3.Text + '*'
		if ($script:communpcname -eq $machine)
		{
			$trouver = Invoke-Command -ScriptBlock { get-software } | Where-Object { $_.displayname -like $logiciel } | select Displayname, version
			
		}
		else
		{
			
			$trouver = Invoke-Command -ComputerName $machine -ScriptBlock ${function:get-software} | Where-Object { $_.displayname -like $logiciel } | select Displayname, version
		}
		
		
		Update-DataGridView -DataGridView $datagridview1 -Item $trouver
	
	}
	
	Function Get-Software
	{
		
		[OutputType('System.Software.Inventory')]
		[Cmdletbinding()]
		Param (
			
			[Parameter(ValueFromPipeline = $True, ValueFromPipelineByPropertyName = $True)]
			[String[]]$Computer = $env:COMPUTERNAME
			
		)
		
		Begin
		{
			
		}
		
		Process
		{
			
			$Paths = @("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", "SOFTWARE\\Wow6432node\\Microsoft\\Windows\\CurrentVersion\\Uninstall")
			
			ForEach ($Path in $Paths)
			{
				
				Write-Verbose  "Checking Path: $Path"
				
				#  Create an instance of the Registry Object and open the HKLM base key 
				
				Try
				{
					
					$reg = [microsoft.win32.registrykey]::OpenRemoteBaseKey('LocalMachine', $Computer, 'Registry64')
					
				}
				Catch
				{
					
					Write-Error $_
					
					Continue
					
				}
				
				#  Drill down into the Uninstall key using the OpenSubKey Method 
				
				Try
				{
					
					$regkey = $reg.OpenSubKey($Path)
					
					# Retrieve an array of string that contain all the subkey names 
					
					$subkeys = $regkey.GetSubKeyNames()
					
					# Open each Subkey and use GetValue Method to return the required  values for each 
					
					ForEach ($key in $subkeys)
					{
						
						Write-Verbose "Key: $Key"
						
						$thisKey = $Path + "\\" + $key
						
						Try
						{
							
							$thisSubKey = $reg.OpenSubKey($thisKey)
							
							# Prevent Objects with empty DisplayName 
							
							$DisplayName = $thisSubKey.getValue("DisplayName")
							
							If ($DisplayName -AND $DisplayName -notmatch '^Update  for|rollup|^Security Update|^Service Pack|^HotFix')
							{
								
								$Date = $thisSubKey.GetValue('InstallDate')
								
								If ($Date)
								{
									
									Try
									{
										
										$Date = [datetime]::ParseExact($Date, 'yyyyMMdd', $Null)
										
									}
									Catch
									{
										
										Write-Warning "$($Computer): $_ <$($Date)>"
										
										$Date = $Null
										
									}
									
								}
								
								# Create New Object with empty Properties 
								
								$Publisher = Try
								{
									
									$thisSubKey.GetValue('Publisher').Trim()
									
								}
								
								Catch
								{
									
									$thisSubKey.GetValue('Publisher')
									
								}
								
								$Version = Try
								{
									
									#Some weirdness with trailing [char]0 on some strings
									
									$thisSubKey.GetValue('DisplayVersion').TrimEnd(([char[]](32, 0)))
									
								}
								
								Catch
								{
									
									$thisSubKey.GetValue('DisplayVersion')
									
								}
								
								$UninstallString = Try
								{
									
									$thisSubKey.GetValue('UninstallString').Trim()
									
								}
								
								Catch
								{
									
									$thisSubKey.GetValue('UninstallString')
									
								}
								
								$InstallLocation = Try
								{
									
									$thisSubKey.GetValue('InstallLocation').Trim()
									
								}
								
								Catch
								{
									
									$thisSubKey.GetValue('InstallLocation')
									
								}
								
								$InstallSource = Try
								{
									
									$thisSubKey.GetValue('InstallSource').Trim()
									
								}
								
								Catch
								{
									
									$thisSubKey.GetValue('InstallSource')
									
								}
								
								$HelpLink = Try
								{
									
									$thisSubKey.GetValue('HelpLink').Trim()
									
								}
								
								Catch
								{
									
									$thisSubKey.GetValue('HelpLink')
									
								}
								
								$Object = [pscustomobject]@{
									
									Computername	  = $Computer
									
									Displayname	      = $DisplayName
									
									Version		      = $Version
									
									InstallDate	      = $Date
									
									Publisher		  = $Publisher
									
									UninstallString   = $UninstallString
									
									InstallLocation   = $InstallLocation
									
									InstallSource	  = $InstallSource
									
									HelpLink		  = $thisSubKey.GetValue('HelpLink')
									
									EstimatedSizeMB   = [decimal]([math]::Round(($thisSubKey.GetValue('EstimatedSize') * 1024)/1MB, 2))
									
								}
								
								$Object.pstypenames.insert(0, 'System.Software.Inventory')
								
								Write-Output $Object
								
							}
							
						}
						Catch
						{
							
							Write-Warning "$Key : $_"
							
						}
						
					}
					
				}
				Catch { }
				
				$reg.Close()
				
			}
			
			
			
			
			
			
		}
		
	}
	$textbox3_TextChanged={
		#TODO: Place custom script here
		
	}
	
	$RPCInfo_KeyDown=[System.Windows.Forms.KeyEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.KeyEventArgs]
		#TODO: Place custom script here
		
	}
	
	$richtextbox2_TextChanged={
		#TODO: Place custom script here
		
	}
	
	$textbox3_KeyDown=[System.Windows.Forms.KeyEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.KeyEventArgs]
		#TODO: Place custom script here
		if ($_.KeyCode -eq "Enter") { & $button1_Click }
	}
	
	$richtextbox1_TextChanged={
		#TODO: Place custom script here
		
	}
	
	$richtextbox3_TextChanged={
		#TODO: Place custom script here
		
	}
	
	$progressbaroverlay1_Click={
		#TODO: Place custom script here
		
	}
	
	$button2_Click={
		#TODO: Place custom script here
		$machine = $textbox1.Text
		if (!$machine)
		{
			Write-Host pas de poste
		}
		else
		{
		msra.exe /offerra $machine
		}
	}
	
	
	$button3_Click={
		#TODO: Place custom script here
		& $button1_Click
	}
	
	$radiobutton1_CheckedChanged={
		#TODO: Place custom script here
		
	}
	
	$groupbox1_Enter={
		#TODO: Place custom script here
	
	}
	
	$radiobuttonEN_CheckedChanged={
		#TODO: Place custom script here
		$richtextbox1.Text = "Computer Name"
		$richtextbox2.Text = "Software"		
		
	}
	
	
	$radiobuttonFr_CheckedChanged={
		#TODO: Place custom script here
		$richtextbox1.Text = "Nom du Poste"
		$richtextbox2.Text = "Logiciels"
				
	}
	
	$chartDiskSpace_Click={
		#TODO: Place custom script here
		
	}
	
	$chartProcesses2_VisibleChanged={
		if($this.Visible)
		{
			Update-ProcessChart -Chart $this -Top 5	
		}
	}
	
	$chartProcesses1_Click={
		#TODO: Place custom script here
		
	}
	
	$chartProcesses2_VisibleChanged2={
		if($this.Visible)
		{
			Update-ProcessChart -Chart $this -Top 5	
		}
	}
	
	$chartProcesses1_VisibleChanged3={
		if($this.Visible)
		{
			Update-ProcessChart -Chart $this -Top 5	
		}
	}
	
	function Update-ProcessChart1
	{
		Param ([Parameter(Position = 1, Mandatory = $true)]
			[System.Windows.Forms.DataVisualization.Charting.Chart]$Chart,
			[int]$Top = 3)
		
		$Processes = Get-Process | Sort-Object -Property cpu | Select-Object Name, WS, ID, cpu -Last 3
		$ProcNames = @(foreach ($Proc in $Processes)
			{
				$sleepseconds = 1
				$numcores = 8
				$cpu1 = (get-process -id $Proc.id).cpu
				sleep $sleepseconds
				$cpu2 = (get-process -id $proc.id).cpu
				$cpupercent = [int](($cpu2 - $cpu1)/($numcores * $sleepseconds) * 100)
				
				$Proc.Name + " (" + $cpupercent + "%)"
				
			})
		$WS = @(foreach ($Proc in $Processes) { $Proc.WS/1MB })
		
		Update-Chart1 $Chart -XPoints $ProcNames -YPoints $WS -Title "Top $Top Processes"
	}
	
	function Update-MemoryUsageChart1
	{
		Param (
			[ValidateNotNull()]
			[Parameter(Position = 1, Mandatory = $true)]
			[System.Windows.Forms.DataVisualization.Charting.Chart]$Chart,
			[int]$Top = 5)
		
		$processes = Get-Process | sort PrivateMemorySize -Descending | Select-Object -First $Top
		$ProcNames = @(foreach ($Proc in $processes) { $Proc.Name })
		$VirtualMem = @(foreach ($Proc in $processes) { $Proc.VirtualMemorySize/1MB })
		$PrivateMem = @(foreach ($Proc in $processes) { $Proc.PrivateMemorySize/1MB })
		
		#Clear-Chart -ChartControl $Chart
		Update-Chart1 -ChartControl $Chart -ChartType 'Column' -Title "Top $Top - Memory Usage" `
					  -XTitle 'Process Name' -YTitle 'Memory (MB)' -XPoints $ProcNames -YPoints $VirtualMem -SeriesName 'Virtual'
		Update-Chart1 -ChartControl $Chart -XPoints $ProcNames -YPoints $PrivateMem -SeriesName 'Private'
		
	}
	
	function Update-Chart1
	{
	<#
		.SYNOPSIS
			This functions helps you plot points on a chart
		
		.DESCRIPTION
			Use the function to plot points on a chart or add more charts to a chart control
		
		.PARAMETER ChartControl
			The Chart Control you when to add points to
		
		.PARAMETER XPoints
			Set the X Axis Points. These can be strings or numerical values.
		
		.PARAMETER YPoints
			Set the Y Axis Points. These can be strings or numerical values.
		
		.PARAMETER XTitle
			Set the Title for the X Axis.
		
		.PARAMETER YTitle
			Set the Title for the Y Axis.
		
		.PARAMETER Title
			Set the Title for the chart.
		
		.PARAMETER ChartType
			Set the Style of the chart. See System.Windows.Forms.DataVisualization.Charting.SeriesChartType Enum
		
		.PARAMETER SeriesIndex
			Set the settings of a particular Series and corresponding ChartArea
		
		.PARAMETER TitleIndex
			Set the settings of a particular Title
		
		.PARAMETER SeriesName
			Set the settings of a particular Series using its name and corresponding ChartArea.
			The Series will be created if not found.
			If SeriesIndex is set, it will replace the Series' name if the Series does not exist
		
		.PARAMETER Enable3D
			The chart will be rendered in 3D.
		
		.PARAMETER Disable3D
			The chart will be rendered in 2D.
		
		.PARAMETER AppendNew
			When this switch is used, a new ChartArea is added to Chart Control.
		
		.NOTES
			Additional information about the function.
	#>
		
		param
		(
			[Parameter(Mandatory = $true,
					   Position = 1)]
			[ValidateNotNull()]
			[System.Windows.Forms.DataVisualization.Charting.Chart]$ChartControl,
			[Parameter(Mandatory = $true,
					   Position = 2)]
			[ValidateNotNull()]
			$XPoints,
			[Parameter(Mandatory = $true,
					   Position = 3)]
			$YPoints,
			[Parameter(Mandatory = $false,
					   Position = 4)]
			[string]$XTitle,
			[Parameter(Mandatory = $false,
					   Position = 5)]
			[string]$YTitle,
			[Parameter(Mandatory = $false,
					   Position = 6)]
			[string]$Title,
			[Parameter(Mandatory = $false,
					   Position = 7)]
			[System.Windows.Forms.DataVisualization.Charting.SeriesChartType]$ChartType,
			[Parameter(Mandatory = $false,
					   Position = 8)]
			$SeriesIndex = '-1',
			[Parameter(Mandatory = $false,
					   Position = 9)]
			$TitleIndex = '0',
			[Parameter(Mandatory = $false)]
			[string]$SeriesName = $null,
			[switch]$Enable3D,
			[switch]$Disable3D,
			[switch]$AppendNew
		)
		
		$ChartAreaIndex = 0
		if ($AppendNew)
		{
			$name = "ChartArea " + ($ChartControl.ChartAreas.Count + 1).ToString();
			$ChartArea = $ChartControl.ChartAreas.Add($name)
			$ChartAreaIndex = $ChartControl.ChartAreas.Count - 1
			
			$name = "Series " + ($ChartControl.Series.Count + 1).ToString();
			$Series = $ChartControl.Series.Add($name)
			$SeriesIndex = $ChartControl.Series.Count - 1
			
			$Series.ChartArea = $ChartArea.Name
			
			if ($Title)
			{
				$name = "Title " + ($ChartControl.Titles.Count + 1).ToString();
				$TitleObj = $ChartControl.Titles.Add($Title)
				$TitleIndex = $ChartControl.Titles.Count - 1
				$TitleObj.DockedToChartArea = $ChartArea.Name
				$TitleObj.IsDockedInsideChartArea = $false
			}
		}
		else
		{
			if ($ChartControl.ChartAreas.Count -eq 0)
			{
				$name = "ChartArea " + ($ChartControl.ChartAreas.Count + 1).ToString();
				[void]$ChartControl.ChartAreas.Add($name)
				$ChartAreaIndex = $ChartControl.ChartAreas.Count - 1
			}
			
			if ($ChartControl.Series.Count -eq 0)
			{
				if (-not $SeriesName)
				{
					$SeriesName = "Series " + ($ChartControl.Series.Count + 1).ToString();
				}
				
				$Series = $ChartControl.Series.Add($SeriesName)
				$SeriesIndex = $ChartControl.Series.Count - 1
				$Series.ChartArea = $ChartControl.ChartAreas[$ChartAreaIndex].Name
			}
			elseif ($SeriesName)
			{
				$Series = $ChartControl.Series.FindByName($SeriesName)
				
				if ($null -eq $Series)
				{
					if (($SeriesIndex -gt -1) -and ($SeriesIndex -lt $ChartControl.Series.Count))
					{
						$Series = $ChartControl.Series[$SeriesIndex]
						$Series.Name = $SeriesName
					}
					else
					{
						$Series = $ChartControl.Series.Add($SeriesName)
						$SeriesIndex = $ChartControl.Series.Count - 1
					}
					
					$Series.ChartArea = $ChartControl.ChartAreas[$ChartAreaIndex].Name
				}
				else
				{
					$SeriesIndex = $ChartControl.Series.IndexOf($Series)
					$ChartAreaIndex = $ChartControl.ChartAreas.IndexOf($Series.ChartArea)
				}
			}
		}
		
		if (($SeriesIndex -lt 0) -or ($SeriesIndex -ge $ChartControl.Series.Count))
		{
			$SeriesIndex = 0
		}
		
		$Series = $ChartControl.Series[$SeriesIndex]
		$Series.Points.Clear()
		$ChartArea = $ChartControl.ChartAreas[$Series.ChartArea]
		
		if ($Enable3D)
		{
			$ChartArea.Area3DStyle.Enable3D = $true
		}
		elseif ($Disable3D)
		{
			$ChartArea.Area3DStyle.Enable3D = $false
		}
		
		if ($Title)
		{
			if ($ChartControl.Titles.Count -eq 0)
			{
				#$name = "Title " + ($ChartControl.Titles.Count + 1).ToString();
				$TitleObj = $ChartControl.Titles.Add($Title)
				$TitleIndex = $ChartControl.Titles.Count - 1
				$TitleObj.DockedToChartArea = $ChartArea.Name
				$TitleObj.IsDockedInsideChartArea = $false
			}
			
			$ChartControl.Titles[$TitleIndex].Text = $Title
		}
		
		if ($ChartType)
		{
			$Series.ChartType = $ChartType
		}
		
		if ($XTitle)
		{
			$ChartArea.AxisX.Title = $XTitle
		}
		
		if ($YTitle)
		{
			$ChartArea.AxisY.Title = $YTitle
		}
		
		if ($XPoints -isnot [Array] -or $XPoints -isnot [System.Collections.IEnumerable])
		{
			$array = New-Object System.Collections.ArrayList
			$array.Add($XPoints)
			$XPoints = $array
		}
		
		if ($YPoints -isnot [Array] -or $YPoints -isnot [System.Collections.IEnumerable])
		{
			$array = New-Object System.Collections.ArrayList
			$array.Add($YPoints)
			$YPoints = $array
		}
		
		$Series.Points.DataBindXY($XPoints, $YPoints)
	}
	
	function Clear-Chart1
	{
	<#
		.SYNOPSIS
			This function clears the contents of the chart
	
		.DESCRIPTION
			Use the function to remove contents from the chart control
	
		.PARAMETER  ChartControl
			The Chart Control to clear
	
		.PARAMETER  LeaveSingleChart
			Leaves the first chart and removes all others from the control
		
		.LINK
			http://www.sapien.com/blog/2011/05/05/primalforms-2011-designing-charts-for-powershell/
	#>
		Param (
			[ValidateNotNull()]
			[Parameter(Position = 1, Mandatory = $true)]
			[System.Windows.Forms.DataVisualization.Charting.Chart]$ChartControl
			 ,
			[Parameter(Position = 2, Mandatory = $false)]
			[Switch]$LeaveSingleChart
		)
		
		$count = 0
		if ($LeaveSingleChart)
		{
			$count = 1
		}
		
		while ($ChartControl.Series.Count -gt $count)
		{
			$ChartControl.Series.RemoveAt($ChartControl.Series.Count - 1)
		}
		
		while ($ChartControl.ChartAreas.Count -gt $count)
		{
			$ChartControl.ChartAreas.RemoveAt($ChartControl.ChartAreas.Count - 1)
		}
		
		while ($ChartControl.Titles.Count -gt $count)
		{
			$ChartControl.Titles.RemoveAt($ChartControl.Titles.Count - 1)
		}
		
		if ($ChartControl.Series.Count -gt 0)
		{
			$ChartControl.Series[0].Points.Clear()
		}
	}
	
	$chartMemoryUsage_VisibleChanged = {
		
		if ($chartMemoryUsage.Visible)
		{
			Update-MemoryUsageChart1 -Chart $chartMemoryUsage -Top 5
		}
	}
	
	$chartProcesses1_Click = {
		#TODO: Place custom script here
		
		
	}
	
	$chartProcesses1_VisibleChanged = {
		if ($this.Visible)
		{
			Update-ProcessChart1 -Chart $this -Top 5
		}
	}
	
	$rafproc_Click={
		#TODO: Place custom script here
		$val = $textbox1.Text
		$session = New-PSSession -ComputerName $val
		$Processes1 = Invoke-Command -computername $val -ScriptBlock { Get-Process | Sort-Object -Property cpu | Select-Object Name, WS, ID, cpu -Last 3 }
		$ProcNames1 = Invoke-Command -computername $val -ScriptBlock {
					@(foreach ($Proc in (Get-Process | Sort-Object -Property cpu | Select-Object Name, WS, ID, cpu -Last 3))
				{
					$sleepseconds = 1
					$numcores = (gwmi win32_Processor ).numberoflogicalprocessors
					$cpu1 = (get-process -id $Proc.id).cpu
					sleep $sleepseconds
					$cpu2 = (get-process -id $proc.id).cpu
					$cpupercent = [int](($cpu2 - $cpu1)/($numcores * $sleepseconds) * 100)
					$Proc.Name + "  (" + $cpupercent + "%)"
					
				})
		}
		
		$WS1 = @(foreach ($Proc in $Processes1) { $Proc.ws/1MB })
		Update-Chart1 $chartProcesses1 -XPoints $ProcNames1[0] -YPoints $WS1[0]
		$chartProcesses1.Series[0].Points.AddXY($ProcNames1[1], $ws1[1])
		$chartProcesses1.Series[0].Points.AddXY($ProcNames1[2], $ws1[2])
			
	}
	
	$datagridview2_CellContentClick=[System.Windows.Forms.DataGridViewCellEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.DataGridViewCellEventArgs]
		#TODO: Place custom script here
		
	}
	
	$textbox4_TextChanged={
		#TODO: Place custom script here
		
	}
	
	$menustrip1_ItemClicked=[System.Windows.Forms.ToolStripItemClickedEventHandler]{
	#Event Argument: $_ = [System.Windows.Forms.ToolStripItemClickedEventArgs]
		#TODO: Place custom script here
		
	}
	
	$aboutToolStripMenuItem_Click={
		#TODO: Place custom script here
		[System.Windows.Forms.MessageBox]::Show("Real Time Inventory `r`nDevelopped By Dakhama Mehdi `r`n`r`nContribution : DEMAN-BARCELO Thierry`r`nNicolas Baudin`r`n`r`nHelped By : Loic Vierman`r`n Olivier Rabache`r`n` Patrick Izzo`r`n` Zouhair Sarouti `r`n`r`nRelease 05/2021`r`nMicrosoft Windows NT 10.0.17763`r`n.NET V4.7.2", 'RTI-PC')
	}
	
	$exitToolStripMenuItem_Click={
		#TODO: Place custom script here
		$RPCInfo.Close()
	}
	
	# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$RPCInfo.WindowState = $InitialFormWindowState
	}
	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$chartProcesses1.remove_Click($chartProcesses1_Click)
			$datagridview2.remove_CellContentClick($datagridview2_CellContentClick)
			$radiobuttonEN.remove_CheckedChanged($radiobuttonEN_CheckedChanged)
			$radiobuttonFr.remove_CheckedChanged($radiobuttonFr_CheckedChanged)
			$groupbox1.remove_Enter($groupbox1_Enter)
			$button3.remove_Click($button3_Click)
			$button2.remove_Click($button2_Click)
			$progressbaroverlay1.remove_Click($progressbaroverlay1_Click)
			$richtextbox3.remove_TextChanged($richtextbox3_TextChanged)
			$richtextbox2.remove_TextChanged($richtextbox2_TextChanged)
			$textbox3.remove_TextChanged($textbox3_TextChanged)
			$textbox3.remove_KeyDown($textbox3_KeyDown)
			$button1.remove_Click($button1_Click)
			$datagridview1.remove_CellContentClick($datagridview1_CellContentClick)
			$chartDiskSpace.remove_VisibleChanged($chartDiskSpace_VisibleChanged)
			$chartDiskSpace.remove_Click($chartDiskSpace_Click)
			$richtextbox1.remove_TextChanged($richtextbox1_TextChanged)
			$chartProcesses.remove_VisibleChanged($chartProcesses_VisibleChanged)
			$chartProcesses.remove_Click($chartProcesses_Click)
			$textbox2.remove_TextChanged($textbox2_TextChanged)
			$textbox1.remove_TextChanged($textbox1_TextChanged)
			$textbox1.remove_KeyDown($textbox1_KeyDown)
			$buttonOK.remove_Click($buttonOK_Click)
			$menustrip1.remove_ItemClicked($menustrip1_ItemClicked)
			$RPCInfo.remove_Load($RPCInfo_Load)
			$RPCInfo.remove_KeyDown($RPCInfo_KeyDown)
			$aboutToolStripMenuItem.remove_Click($aboutToolStripMenuItem_Click)
			$exitToolStripMenuItem.remove_Click($exitToolStripMenuItem_Click)
			$RPCInfo.remove_Load($Form_StateCorrection_Load)
			$RPCInfo.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch { Out-Null <# Prevent PSScriptAnalyzer warning #> }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$RPCInfo.SuspendLayout()
	$chartProcesses1.BeginInit()
	$groupbox1.SuspendLayout()
	$chartDiskSpace.BeginInit()
	$chartProcesses.BeginInit()
	$menustrip1.SuspendLayout()
	#
	# RPCInfo
	#
	$RPCInfo.Controls.Add($chartProcesses1)
	$RPCInfo.Controls.Add($datagridview2)
	$RPCInfo.Controls.Add($groupbox1)
	$RPCInfo.Controls.Add($button3)
	$RPCInfo.Controls.Add($button2)
	$RPCInfo.Controls.Add($progressbaroverlay1)
	$RPCInfo.Controls.Add($richtextbox3)
	$RPCInfo.Controls.Add($richtextbox2)
	$RPCInfo.Controls.Add($textbox3)
	$RPCInfo.Controls.Add($button1)
	$RPCInfo.Controls.Add($datagridview1)
	$RPCInfo.Controls.Add($chartDiskSpace)
	$RPCInfo.Controls.Add($richtextbox1)
	$RPCInfo.Controls.Add($chartProcesses)
	$RPCInfo.Controls.Add($textbox2)
	$RPCInfo.Controls.Add($textbox1)
	$RPCInfo.Controls.Add($buttonOK)
	$RPCInfo.Controls.Add($menustrip1)
	$RPCInfo.AutoScaleDimensions = '6, 13'
	$RPCInfo.AutoScaleMode = 'Font'
	$RPCInfo.BackColor = 'SteelBlue'
	$RPCInfo.ClientSize = '1156, 541'
	$RPCInfo.FormBorderStyle = 'Fixed3D'
	#region Binary Data
	$RPCInfo.Icon = [System.Convert]::FromBase64String('')
	#endregion
	$button2.Location = '186, 28'
	$button2.Name = 'button2'
	$button2.Size = '67, 25'
	$button2.TabIndex = 11
	$button2.UseCompatibleTextRendering = $True
	$button2.UseVisualStyleBackColor = $True
	$button2.add_Click($button2_Click)
	#
	# progressbaroverlay1
	#
	$progressbaroverlay1.Location = '12, 79'
	$progressbaroverlay1.Name = 'progressbaroverlay1'
	$progressbaroverlay1.Size = '241, 23'
	$progressbaroverlay1.TabIndex = 10
	$progressbaroverlay1.Visible = $False
	$progressbaroverlay1.add_Click($progressbaroverlay1_Click)
	#
	# richtextbox3
	#
	$richtextbox3.BackColor = 'SteelBlue'
	$richtextbox3.BorderStyle = 'None'
	$richtextbox3.Font = 'Times New Roman, 9pt'
	$richtextbox3.ForeColor = 'White'
	$richtextbox3.Location = '387, 23'
	$richtextbox3.Name = 'richtextbox3'
	$richtextbox3.Size = '150, 26'
	$richtextbox3.TabIndex = 9
	$richtextbox3.Text = ''
	$richtextbox3.add_TextChanged($richtextbox3_TextChanged)
	#
	# richtextbox2
	#
	$richtextbox2.BackColor = 'SteelBlue'
	$richtextbox2.BorderStyle = 'None'
	$richtextbox2.Font = 'Times New Roman, 12pt'
	$richtextbox2.Location = '927, 6'
	$richtextbox2.Name = 'richtextbox2'
	$richtextbox2.ReadOnly = $True
	$richtextbox2.Size = '150, 27'
	$richtextbox2.TabIndex = 8
	$richtextbox2.Text = 'Logiciels'
	$richtextbox2.add_TextChanged($richtextbox2_TextChanged)
	#
	# textbox3
	#
	$textbox3.Location = '927, 33'
	$textbox3.MaxLength = 15
	$textbox3.Name = 'textbox3'
	$textbox3.Size = '151, 20'
	$textbox3.TabIndex = 7
	$textbox3.add_TextChanged($textbox3_TextChanged)
	$textbox3.add_KeyDown($textbox3_KeyDown)
	#
	# button1
	#
	$button1.DialogResult = 'Cancel'
	$button1.Location = '1082, 4'
	$button1.Name = 'button1'
	$button1.Size = '56, 23'
	$button1.TabIndex = 6
	$button1.Text = 'OK'
	$button1.UseCompatibleTextRendering = $True
	$button1.UseVisualStyleBackColor = $True
	$button1.Visible = $False
	$button1.add_Click($button1_Click)
	#
	# datagridview1
	#
	$datagridview1.AccessibleDescription = '²'
	$datagridview1.AllowUserToDeleteRows = $False
	$datagridview1.AllowUserToResizeColumns = $False
	$datagridview1.AllowUserToResizeRows = $False
	$System_Windows_Forms_DataGridViewCellStyle_4 = New-Object 'System.Windows.Forms.DataGridViewCellStyle'
	$System_Windows_Forms_DataGridViewCellStyle_4.Alignment = 'TopLeft'
	$datagridview1.AlternatingRowsDefaultCellStyle = $System_Windows_Forms_DataGridViewCellStyle_4
	$datagridview1.Anchor = 'Top, Bottom, Left, Right'
	$datagridview1.AutoSizeColumnsMode = 'Fill'
	$datagridview1.AutoSizeRowsMode = 'AllCells'
	$datagridview1.BackgroundColor = 'SteelBlue'
	$datagridview1.BorderStyle = 'None'
	$datagridview1.ColumnHeadersBorderStyle = 'Single'
	$datagridview1.ColumnHeadersHeightSizeMode = 'AutoSize'
	$datagridview1.GridColor = 'AppWorkspace'
	$datagridview1.Location = '927, 62'
	$datagridview1.Name = 'datagridview1'
	$datagridview1.ReadOnly = $True
	$datagridview1.RowHeadersVisible = $False
	$datagridview1.Size = '220, 218'
	$datagridview1.TabIndex = 5
	$datagridview1.add_CellContentClick($datagridview1_CellContentClick)
	#
	# chartDiskSpace
	#
	$chartDiskSpace.AccessibleRole = 'None'
	$chartDiskSpace.BackColor = 'Transparent'
	$chartDiskSpace.BackImageTransparentColor = 'Transparent'
	$chartDiskSpace.BackSecondaryColor = 'Aqua'
	$chartDiskSpace.BorderlineColor = 'SteelBlue'
	$chartDiskSpace.BorderSkin.BackImageTransparentColor = 'Lime'
	$chartDiskSpace.BorderSkin.BackSecondaryColor = 'Lime'
	$chartDiskSpace.BorderSkin.PageColor = 'Transparent'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5 = New-Object 'System.Windows.Forms.DataVisualization.Charting.ChartArea'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AlignmentOrientation = 'All'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AlignmentStyle = 'None'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.Area3DStyle.Enable3D = $True
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisX.InterlacedColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisX.ScrollBar.BackColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisX.ScrollBar.ButtonColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisX.ScrollBar.LineColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisX.Title = 'Disk'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisX.TitleForeColor = 'White'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisX2.InterlacedColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisX2.ScrollBar.BackColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisX2.ScrollBar.ButtonColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisX2.ScrollBar.LineColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisX2.TitleForeColor = 'White'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisY.InterlacedColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisY.ScrollBar.BackColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisY.ScrollBar.ButtonColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisY.ScrollBar.LineColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisY.Title = 'Disk Space (MB) '
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisY.TitleForeColor = 'White'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisY2.InterlacedColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisY2.ScrollBar.BackColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisY2.ScrollBar.ButtonColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisY2.ScrollBar.LineColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.AxisY2.TitleForeColor = 'White'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.BackColor = 'Transparent'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.BackImageTransparentColor = 'SteelBlue'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.BackSecondaryColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.IsSameFontSizeForAllAxes = $True
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.Name = 'ChartArea1'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_5.ShadowColor = 'SteelBlue'
	[void]$chartDiskSpace.ChartAreas.Add($System_Windows_Forms_DataVisualization_Charting_ChartArea_5)
	$chartDiskSpace.Location = '259, 269'
	$chartDiskSpace.Name = 'chartDiskSpace'
	$chartDiskSpace.RightToLeft = 'No'
	$System_Windows_Forms_DataVisualization_Charting_Series_6 = New-Object 'System.Windows.Forms.DataVisualization.Charting.Series'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.BackGradientStyle = 'LeftRight'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.BackHatchStyle = 'BackwardDiagonal'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.BackImageTransparentColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.BackSecondaryColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.BorderColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.ChartArea = 'ChartArea1'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.ChartType = 'Pie'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.Color = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.CustomProperties = 'DrawingStyle=Cylinder, CollectedColor=White, PieDrawingStyle=Concave'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.EmptyPointStyle.BackGradientStyle = 'LeftRight'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.EmptyPointStyle.BackHatchStyle = 'BackwardDiagonal'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.EmptyPointStyle.BackImageTransparentColor = '255, 255, 192'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.EmptyPointStyle.BackSecondaryColor = '255, 255, 192'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.EmptyPointStyle.Color = '128, 255, 128'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.EmptyPointStyle.CustomProperties = 'PieLineColor=192\, 255\, 192'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.EmptyPointStyle.LabelBackColor = '192, 255, 192'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.LabelBackColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.LabelBorderColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.Legend = 'Legend1'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.MarkerBorderColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.Name = 'Disk Space'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.SmartLabelStyle.CalloutBackColor = 'LightGreen'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.SmartLabelStyle.CalloutLineAnchorCapStyle = 'Diamond'
	$System_Windows_Forms_DataVisualization_Charting_Series_6.YValuesPerPoint = 4
	[void]$chartDiskSpace.Series.Add($System_Windows_Forms_DataVisualization_Charting_Series_6)
	$chartDiskSpace.Size = '244, 256'
	$chartDiskSpace.TabIndex = 0
	$chartDiskSpace.TabStop = $False
	$chartDiskSpace.Text = 'chartdisk'
	$System_Windows_Forms_DataVisualization_Charting_Title_7 = New-Object 'System.Windows.Forms.DataVisualization.Charting.Title'
	$System_Windows_Forms_DataVisualization_Charting_Title_7.Alignment = 'TopCenter'
	$System_Windows_Forms_DataVisualization_Charting_Title_7.BackColor = 'Transparent'
	$System_Windows_Forms_DataVisualization_Charting_Title_7.DockedToChartArea = 'ChartArea1'
	$System_Windows_Forms_DataVisualization_Charting_Title_7.ForeColor = 'White'
	$System_Windows_Forms_DataVisualization_Charting_Title_7.IsDockedInsideChartArea = $False
	$System_Windows_Forms_DataVisualization_Charting_Title_7.Name = 'Title1'
	$System_Windows_Forms_DataVisualization_Charting_Title_7.Text = 'Disk Space '
	[void]$chartDiskSpace.Titles.Add($System_Windows_Forms_DataVisualization_Charting_Title_7)
	$chartDiskSpace.add_VisibleChanged($chartDiskSpace_VisibleChanged)
	$chartDiskSpace.add_Click($chartDiskSpace_Click)
	#
	# richtextbox1
	#
	$richtextbox1.BackColor = 'SteelBlue'
	$richtextbox1.BorderStyle = 'None'
	$richtextbox1.Font = 'Times New Roman, 12pt'
	$richtextbox1.Location = '12, 31'
	$richtextbox1.Name = 'richtextbox1'
	$richtextbox1.ReadOnly = $True
	$richtextbox1.Size = '158, 22'
	$richtextbox1.TabIndex = 3
	$richtextbox1.Text = 'Nom du Poste'
	$richtextbox1.add_TextChanged($richtextbox1_TextChanged)
	#
	# chartProcesses
	#
	$chartProcesses.BackColor = 'SteelBlue'
	$chartProcesses.BackGradientStyle = 'LeftRight'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_8 = New-Object 'System.Windows.Forms.DataVisualization.Charting.ChartArea'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_8.AlignmentOrientation = 'All'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_8.Area3DStyle.IsClustered = $True
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_8.Area3DStyle.LightStyle = 'None'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_8.AxisY.Title = '(MB)'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_8.BackColor = 'Transparent'
	$System_Windows_Forms_DataVisualization_Charting_ChartArea_8.Name = 'ChartArea1'
	[void]$chartProcesses.ChartAreas.Add($System_Windows_Forms_DataVisualization_Charting_ChartArea_8)
	$chartProcesses.Location = '259, 57'
	$chartProcesses.Name = 'chartProcesses'
	$System_Windows_Forms_DataVisualization_Charting_Series_9 = New-Object 'System.Windows.Forms.DataVisualization.Charting.Series'
	$System_Windows_Forms_DataVisualization_Charting_Series_9.ChartArea = 'ChartArea1'
	$System_Windows_Forms_DataVisualization_Charting_Series_9.ChartType = 'StackedBar'
	$System_Windows_Forms_DataVisualization_Charting_Series_9.CustomProperties = 'DrawingStyle=Cylinder'
	$System_Windows_Forms_DataVisualization_Charting_Series_9.IsVisibleInLegend = $False
	$System_Windows_Forms_DataVisualization_Charting_Series_9.Name = 'Process WS'
	$System_Windows_Forms_DataVisualization_Charting_Series_9.Palette = 'Pastel'
	$System_Windows_Forms_DataVisualization_Charting_Series_9.YValuesPerPoint = 5
	[void]$chartProcesses.Series.Add($System_Windows_Forms_DataVisualization_Charting_Series_9)
	$chartProcesses.Size = '380, 206'
	$chartProcesses.TabIndex = 0
	$chartProcesses.Text = 'chartproc'
	$System_Windows_Forms_DataVisualization_Charting_Title_10 = New-Object 'System.Windows.Forms.DataVisualization.Charting.Title'
	$System_Windows_Forms_DataVisualization_Charting_Title_10.BackColor = 'Transparent'
	$System_Windows_Forms_DataVisualization_Charting_Title_10.Name = 'Title1'
	$System_Windows_Forms_DataVisualization_Charting_Title_10.Text = 'Consommation de la RAM Par Processeur'
	[void]$chartProcesses.Titles.Add($System_Windows_Forms_DataVisualization_Charting_Title_10)
	$chartProcesses.add_VisibleChanged($chartProcesses_VisibleChanged)
	$chartProcesses.add_Click($chartProcesses_Click)
	#
	# textbox2
	#
	$textbox2.AccessibleRole = 'None'
	$textbox2.BackColor = 'ButtonFace'
	$textbox2.BorderStyle = 'None'
	$textbox2.Location = '12, 79'
	$textbox2.Multiline = $True
	$textbox2.Name = 'textbox2'
	$textbox2.ReadOnly = $True
	$textbox2.ScrollBars = 'Vertical'
	$textbox2.Size = '241, 446'
	$textbox2.TabIndex = 2
	$textbox2.TabStop = $False
	$textbox2.add_TextChanged($textbox2_TextChanged)
	#
	# textbox1
	#
	$textbox1.Location = '12, 53'
	$textbox1.MaxLength = 15
	$textbox1.Name = 'textbox1'
	$textbox1.Size = '168, 20'
	$textbox1.TabIndex = 1
	$textbox1.add_TextChanged($textbox1_TextChanged)
	$textbox1.add_KeyDown($textbox1_KeyDown)
	#
	# buttonOK
	#
	$buttonOK.Location = '186, 53'
	$buttonOK.Name = 'buttonOK'
	$buttonOK.Size = '67, 23'
	$buttonOK.TabIndex = 0
	$buttonOK.Text = 'OK'
	$buttonOK.UseCompatibleTextRendering = $True
	$buttonOK.UseVisualStyleBackColor = $True
	$buttonOK.add_Click($buttonOK_Click)
	#
	# menustrip1
	#
	$menustrip1.BackColor = 'SteelBlue'
	$menustrip1.Dock = 'None'
	[void]$menustrip1.Items.Add($fileToolStripMenuItem)
	[void]$menustrip1.Items.Add($aboutToolStripMenuItem)
	$menustrip1.Location = '0, 4'
	$menustrip1.Name = 'menustrip1'
	$menustrip1.Size = '108, 27'
	$menustrip1.TabIndex = 18
	$menustrip1.Text = 'menustrip1'
	$menustrip1.add_ItemClicked($menustrip1_ItemClicked)
	#
	# fileToolStripMenuItem
	#
	$fileToolStripMenuItem.DisplayStyle = 'Text'
	[void]$fileToolStripMenuItem.DropDownItems.Add($exitToolStripMenuItem)
	$fileToolStripMenuItem.Font = 'Segoe UI, 10pt'
	$fileToolStripMenuItem.Name = 'fileToolStripMenuItem'
	$fileToolStripMenuItem.Size = '41, 23'
	$fileToolStripMenuItem.Text = 'File'
	$fileToolStripMenuItem.TextAlign = 'MiddleLeft'
	#
	# aboutToolStripMenuItem
	#
	$aboutToolStripMenuItem.DisplayStyle = 'Text'
	$aboutToolStripMenuItem.Font = 'Segoe UI, 10pt'
	$aboutToolStripMenuItem.ImageAlign = 'MiddleLeft'
	$aboutToolStripMenuItem.Name = 'aboutToolStripMenuItem'
	$aboutToolStripMenuItem.Size = '59, 23'
	$aboutToolStripMenuItem.Text = 'About'
	$aboutToolStripMenuItem.add_Click($aboutToolStripMenuItem_Click)
	#
	# exitToolStripMenuItem
	#
	$exitToolStripMenuItem.Name = 'exitToolStripMenuItem'
	$exitToolStripMenuItem.Size = '152, 24'
	$exitToolStripMenuItem.Text = 'Exit'
	$exitToolStripMenuItem.add_Click($exitToolStripMenuItem_Click)
	$menustrip1.ResumeLayout()
	$chartProcesses.EndInit()
	$chartDiskSpace.EndInit()
	$groupbox1.ResumeLayout()
	$chartProcesses1.EndInit()
	$RPCInfo.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $RPCInfo.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$RPCInfo.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$RPCInfo.add_FormClosed($Form_Cleanup_FormClosed)
	#Show the Form
	return $RPCInfo.ShowDialog()

} #End Function

#Call the form
Show-RTI-PC-radio-test-spourentage-4-with-proc-new_psf | Out-Null
